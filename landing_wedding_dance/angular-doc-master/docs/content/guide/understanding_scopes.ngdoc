@ngdoc overview
@name Developer Guide: Понимание областей
@description

**Резюме:**

В AngularJS, дочерняя область видимости обычно прототипически наследуется от родительской. Единственным исключением 
является директива, в которой используется `scope: { ... }`, что создает «изолированную» область видимости,
которая не наследуется прототипически. Такая конструкция часто используется при создании директивы для компонента
«многоразового использования»

Наследование областей, как правило, прямое, и часто даже не нужно знать, как оно делается... пока не столкнешься
с **двухсторонней привязкой данных** (т. е. элементами формы, ng-model) **к примитивам** (напр., числу, строке, 
логическому типу), определенными в родительской области видимости из дочерней. Она работает не так, как этого
ожидают большинство людей. Происходит так, что потомок создает собственную область видимости, которая перекрывает
родительское свойство с одноименным названием. Это не особенность AngularJS, так работает прототипное наследование в 
JavaScript. Новые разработчики AngularJS часто не понимают, что ng-repeat, ng-switch, ng-view и ng-include 
создают новые дочерние области, так что проблема появляется при использовании этих директив.

Этой проблемы легко избежать, следуя «[лучшим практикам](http://habrahabr.ru/post/181882/)», где
говорится, что выражение в ng-model должно всегда содержать точку.

Точка «.» в модели гарантирует, что прототипное наследование работает как надо. Поэтому <br>
`<input type="text" ng-model="someObj.prop1">` лучше чем <br>
`<input type="text" ng-model="prop1">`.

Если действительно хотите/нужно использовать примитивы, есть два пути решения проблемы:

  1. Используйте `$parent.parentScopeProperty` в дочерней области видимости. Это запретит дочерней области создавать
     собственное свойство.
  2. Определите функцию в родительской области видимости, и обратитесь к ней из потомка, передавая элементарное 
     значение в родителя (не всегда возможно)

**Детали:**

* [Прототипное наследование в JavaScript](#JSproto)
* [Наследование областей видимости в Angular](#Angular)
  * [ng-include](#ngInclude)
  * [ng-switch](#ngSwitch)
  * [ng-repeat](#ngRepeat)
  * [ng-view](#ngView)
  * [ng-controller](#ngController)
  * [directives](#directives)

## <a id="JSproto"></a>Прототипное наследование в JavaScript

В первую очередь, важно иметь четкое представление о прототипном наследовании в JavaScript, особенно если 
пришли из серверного программирования и больше знакомы с классическим наследованием.

Предположим parentScope имеет свойства aString, aNumber, anArray, anObject, и aFunction. Если childScope
прототипически наследуется от parentScope, имеем:

![нормальное прототипное наследование](http://i.stack.imgur.com/aTAGg.png)

(Обратите внимание, что для экономии места, объект `anArray` показан как одиночный объект с тремя значениями,
а не объект с тремя строками.)

Если попытаться получить доступ к свойствам по умолчанию, определенным в parentScope, из дочерней области видимости,
JavaScript сначала ищет в дочерней области и, не найдя там, затем смотрит в родительской области и уже там находит 
свойство. (Если бы не нашел в parentScope, то продолжил бы поиск по цепочке прототипов... вплоть до корневой области
видимости). Итак, все утверждения ниже верны:
<pre>
  childScope.aString === 'parent string'
  childScope.anArray[1] === 20
  childScope.anObject.property1 === 'parent prop1'
  childScope.aFunction() === 'parent output'
</pre>
Предположим, что после этого сделали так:
<pre>
  childScope.aString = 'child string'
</pre>
Цепочка прототипов не расматривается, а новое свойство aString добавляется в childScope. **Новое свойство 
перекрывает свойство из parentScope с таким же названием.** Это будет очень важным, при обсуждении ng-repeat и
ng-include ниже.

![перекрытие](http://i.stack.imgur.com/OyVPW.png)

Предположим, что после этого сделали так:
<pre>
  childScope.anArray[1] = '22'
  childScope.anObject.property1 = 'child prop1'
</pre>
Цепочка прототипов рассматривается, так как объекты (anArray и anObject) не найдены в childScope. Объекты
находятся в parentScope, а значения свойств обновляются в исходных объектах. Новые свойства не добавляются в
childScope; новые объекты не создаются. (Отметим, что в JavaScript массивы и функции также являются объектами.)

![следование по цепочке](http://i.stack.imgur.com/2QceU.png)

Предположим, что после этого сделали так:
<pre>
  childScope.anArray = [100, 555]
  childScope.anObject = { name: 'Mark', country: 'USA' }
</pre>
Цепочка прототипов опять не рассматривается, и дочерняя область видимости получает два новых свойства объекта, которые
перекрывают свойства объекта из parentScope с теми же именами.

![не следование по цепочке](http://i.stack.imgur.com/hKetH.png)

Подытожим:

* Если читаем childScope.propertyX и childScope содержит propertyX, то цепочка прототипов не рассматривается.
* Если устанавливаем childScope.propertyX, цепочка прототипов рассматривается.

И последний сценарий:
<pre>
  delete childScope.anArray
  childScope.anArray[1] === 22  // true
</pre>
Сперва удалим свойство из childScope, а затем, когда попытаемся получить доступ к свойству снова, состоится переход
по цепочке прототипов.

![после удаления свойства](http://i.stack.imgur.com/56uoe.png)

## <a id="Angular"></a>Наследование областей видимости в Angular

Соучастники:

* Создают новые области видимости, которые прототипически наследуются: ng-repeat, ng-include, ng-switch,
  ng-view, ng-controller, директивы с `scope: true`, директивы с `transclude: true`.
* Создает новую область, которая не наследуется прототипически: директивы с `scope: { ... }`. Вместо этого они
  создают «изолированную» область видимости.

Обратите внимание, что по умолчанию, директивы не создают новые области, т.е. по умолчанию `scope: false`.

### <a id="ngInclude"></a>ng-include

Предположим, что имеем в контроллере:
<pre>
  $scope.myPrimitive = 50;
  $scope.myObject    = {aNumber: 11};
</pre>
И в HTML:
<pre>
  <script type="text/ng-template" id="/tpl1.html">
    <input ng-model="myPrimitive">
  </script>
  <div ng-include src="'/tpl1.html'"></div>

  <script type="text/ng-template" id="/tpl2.html">
    <input ng-model="myObject.aNumber">
  </script>
  <div ng-include src="'/tpl2.html'"></div>
</pre>
Каждая ng-include создает новую дочернюю область видимости, прототипически унаследованную от родительской области.

![ng-include](http://i.stack.imgur.com/ziDfx.png)

Ввод (скажем, «77») в первом текстовом поле приведет к тому, что дочерняя область видимости получит новое свойство 
myPrimitive из области видимости, которое перекроет свойство родительской области с одноименным названием.

Вероятно, это не то, чего вы хотите или ожидаете.

![примитив в ng-include](http://i.stack.imgur.com/7l8dg.png)

Ввод (скажем, «99») во втором текстовом поле не приводит к созданию новой дочерней области видимости. Потому что
tpl2.html связывает модель со свойством объекта, прототипное наследование заканчивается, когда ngModel ищет объект
MyObject — находит его в родительской области.

![объект в ng-include](http://i.stack.imgur.com/QjvVK.png)

**Примечание:** на изображении выше ошибка, число «99» должно заменить 11, а не 50.

Можно переписать первый шаблон с использованием $parent, если не хотим менять модель из примитива на объект:
<pre>
  <input ng-model="$parent.myPrimitive">
</pre>
Ввод (скажем, «22») в этом текстовом поле не имеет последствий для нового дочернего свойства. Модель теперь связана 
со свойством родительской области (потому что $parent является свойством дочерней области видимости, ссылающимся 
на родительскую область).

![$parent в ng-include](http://i.stack.imgur.com/kd8pj.png)

Для всех областей видимости (прототипных или нет), Angular всегда отслеживает отношения родитель-ребенок 
(т. е. иерархию), через свойства $parent, $$childHead и $$childTail в области видимости. Эти свойства обычно не
показываются на диаграммах.

В случаях, когда элементы формы не задействуются, другим решением будет определение функции в родительской области
видимости для измения примитива. Только убедитесь, что потомок всегда вызывает эту функцию, которая будет 
доступна в дочерней области видимости в соответствии с прототипными наследованием. Например,
<pre>
  // в родительской области видимости
  $scope.setMyPrimitive = function(value) {
    $scope.myPrimitive = value;
  }
</pre>
Здесь [простой фидл](http://jsfiddle.net/mrajcok/jNxyE/), который использует подход с «родительской функцией».
(Являлся частью [поста на Stack Overflow](http://stackoverflow.com/a/14104318/215945).)

См. так же {@link http://stackoverflow.com/a/13782671/215945} и {@link https://github.com/angular/angular.js/issues/1267}.

### <a id="ngSwitch"></a> ng-switch

Наследование область видимости в ng-switch работает так же как в ng-include. Так что если нуждаетесь в двухсторонней
привязке данных к примитиву в родительской области видимости, используйте $parent или измените модель на объект, 
а затем привяжите к свойству этого объекта. Это позволит избежать перекрытия свойств родительской области свойствами
дочерней.

См. так же [AngularJS, bind scope of a switch-case?](http://stackoverflow.com/questions/12405005/angularjs-bind-scope-of-a-switch-case/12414410)

### <a id="ngRepeat"></a> ng-repeat

ng-repeat работает немного по-другому. Предположим, что в контроллере содержится следующее:
<pre>
  $scope.myArrayOfPrimitives = [ 11, 22 ];
  $scope.myArrayOfObjects    = [{num: 101}, {num: 202}]
</pre>
И в HTML:
<pre>
  <ul>
    <li ng-repeat="num in myArrayOfPrimitives">
      <input ng-model="num">
    </li>
  <ul>
  <ul>
    <li ng-repeat="obj in myArrayOfObjects">
      <input ng-model="obj.num">
    </li>
  <ul>
</pre>
Для каждого элемента/итерации, ng-repeat создает новую область видимости, которая прототипически наследуется от
родительской, **но он также присваивает значение элемента новым свойствам в новой дочерней области**. (Названием
нового свойства является имя переменной из цикла.) Ниже показан фактический исходный код для ng-repeat:
<pre>
  childScope = scope.$new(); // дочерняя область прототипически наследуется от родительской ...     
  childScope[valueIdent] = value; // создает новое свойство в childScope
</pre>
Если элемент является примитивом (как в myArrayOfPrimitives), по сути, копии значения присваивается новое свойство
дочерней области видимости. Изменение значения свойства в дочерней области (т. е., свойства `num`, унаследованного 
из ng-model) **не** изменяет массив ссылок в родительской области. Таким образом, в первом ng-repeat выше, 
каждая дочерняя область видимости получает свойство `num`, которое не зависит от массива myArrayOfPrimitives:

![примитив в ng-repeat](http://i.stack.imgur.com/nLoiW.png)

ng-repeat не будет работать (как хотите или ожидаете). В Angular 1.0.2 или более раннем, ввод в поля ввода, 
изменяет значения в серых блоках, которые видны только в дочерних областях. В Angular 1.0.3 +, ввод
в текстовые поля никак на них не влияет. (См. пояснения Артема, почему так на [StackOverflow](http://stackoverflow.com/a/13723990/215945).)
Мы же хотим, чтобы ввод влиял на массив myArrayOfPrimitives, а не на свойство дочерней области видимости. 
Чтобы достичь этого, необходимо заменить модель на массив объектов.

Если элемент является объектом, то по ссылке на исходный объект (не копии) присваивается новое свойство дочерней
области видимости. Изменение значения свойства из дочерней области (т. е., свойства `num`, унаследованного из ng-model)
**изменяет** объект по ссылке из родительской области. Так во втором ng-repeat выше, мы имеем:

![объект в ng-repeat](http://i.stack.imgur.com/QSjTJ.png)

(серая линия показывает куда он переходит.)

Это работает, как ожидалось. Ввод в поля ввода, изменяет значения в серой области, которые видны и в дочерней
и в родительской областях видимости.

См. так же [Сложности с ng-model, ng-repeat, и inputs](http://stackoverflow.com/questions/13714884/difficulty-with-ng-model-ng-repeat-and-inputs) и [ng-repeat and databinding](http://stackoverflow.com/a/13782671/215945)

### <a id="ngView"></a> ng-view

Уточняется, но думаю, что действует так же, как ng-include.

### <a id="ngController"></a> ng-controller

Вложенные контроллеры (с использованием ng-controller) подчиняются нормальному прототипному наследованию,
как ng-include и ng-switch, так что к ним применимы те же методы. Тем не менее «считается дурным тоном 
обмениваться информацией между двумя контроллерами через наследование $scope» — 
{@link http://onehungrymind.com/angularjs-sticky-notes-pt-1-architecture/}. Вместо этого необходимо использовать 
сервис.

(Если действительно необходимо поделиться данными через наследование области видимости контроллеров, то делать
ничего не надо. Дочерняя область видимости будет иметь доступ ко всем свойствам в родительской области. См. также
[Controller load order differs when loading or navigating](http://stackoverflow.com/questions/13825419/controller-load-order-differs-when-loading-or-navigating/13843771#13843771))

### <a id="directives"></a> Диретивы

  1. по умолчанию (`scope: false`) — директива не создать новую область видимости, так что никакого наследования не
  происходит. Это легко, но опасно, потому что, например, директива может подумать, что создает новое свойство в
  области видимости, когда фактически она затрет существующее свойство. Не лучший выбор при написании директив,
  предназначенных для компонентов многоразового использования.
  2. `scope: true` — директива создает новую дочернюю область видимости, прототипически унаследованную от
  родительской области. Если более чем одна директива (на одном и том же DOM элементе) запрашивают новую область,
  все равно будет создана только одна дочерняя область. Т. к. у нас «нормальное» прототипное наследование, 
  как в ng-include и ng-switch, то будьте осторожны с двухсторонней привязкой данных к примитивам родительской
  области видимости и перекрытием свойств родительской области свойствами дочерней.
  3. `scope: { ... }` — директива создает новые изолированные области видимости. Они не наследуются прототипически. 
  Как правило, это лучший вариант для создания компонентов многоразового использования, т. к. директива не сможет
  случайно прочитать или изменить данные из родительской области. тем не менее, таким директивам часто необходим
  доступ к некоторым свойствам из родительской области. Хэш-объект используется для создания двухсторонней привязки
  (с помощью «=») или односторонней (с помощью «@») между родительской областью и изолированной. Есть так же «&» 
  для привязки к выражениям в родительской области. Таким образом, все они создают локальные свойства области
  видимости, получаемые из родительской области. Обратите внимание, что атрибуты используются чтобы помочь установить
  привязки — невозможно сослаться на имена свойств из родительской области в хэш-объекте, без использования этих 
  атрибутов. Например, привязка к родительскому свойству `parentProp` в изолированной области: `<div my-directive>` 
  и `scope: { localProp: '@parentProp' }` не будет работать. Атрибут должен использоваться для указания на каждое
  родительское свойство к которому нужно привязаться в директиве: `<div my-directive the-Parent-Prop=parentProp>` и
  `scope: { localProp: '@theParentProp' }`.
<br>`__proto__` изолированной области ссылается на объект [Scope](http://docs.angularjs.org/api/ng.$rootScope.Scope) 
(рисунок ниже необходимо обновить, чтобы показать оранжевый объект «Scope» вместо «Object»). $parent изолированной
области ссылается на родительскую область видимости, так что, хотя он изолированный и не наследуется прототипически
от родительской области, он всё же является потомком.
<br>Для рисунка ниже имеем
<br>`<my-directive interpolated="{{parentProp1}}" twowayBinding="parentProp2">` и
<br> `scope: { interpolatedProp: '@interpolated', twowayBindingProp: '=twowayBinding' }` 
<br>Предположим так же, что директива делает это в связующей функции: `scope.someIsolateProp = "I'm isolated"`
<br>![изолированная область видимости](http://i.stack.imgur.com/MUxS4.png)
<br>Последнее замечание: используйте `attrs.$observe('attr_name', function(value) { ... }` в связующей функции
для получения интерполированного значения свойства из изолированной области видимости, записанного с помощью «@».
Например, если такое содержится в связующей функции — `attrs.$observe('interpolated', function(value) { ... }` —
`value` будет установлено в 11.  (`scope.interpolatedProp` не определено в связующей функции. В противоположность
этому, `scope.twowayBindingProp` определено в связующей функции, т. к. задано с помощью «=».)
<br>Подробнее об изолированных областях видимости читайте в {@link http://onehungrymind.com/angularjs-sticky-notes-pt-2-isolated-scope/}
  4. `transclude: true` — директива создает новую «включенную» дочернюю область видимости, которая прототипически
  наследуется от родительской области. Поэтому, если включенный контент (т. е., материал, который будет заменен
  ng-transclude) требует двухстороннюю привязку данных к примитиву из родительской области видимости, используйте 
  $parent или превратите модель в объект и затем привяжитесь к его свойству, что позволит избежать перекрытия
  свойства родительской области свойством дочерней
<br>Включенная и изолированная области видимости (если таковые имеются) являются потомками одно уровня — 
  свойство $parent каждой из этих областей ссылается на одного и того же родителя. Если существуют и включенная и 
  изолированная области, свойство $$nextSibling изолированной области будет ссылаться на включенную область.
<br>По включенным областям видимости см. так же [AngularJS two way binding not working in directive with transcluded scope](http://stackoverflow.com/a/14484903/215945)
<br>Для рисунка ниже имеем, такую же директиву как указано выше с этим дополнением: `transclude: true`
<br>![включенная область видимости](http://i.stack.imgur.com/fkWHA.png)

Этот [фидл](http://jsfiddle.net/mrajcok/7g3QM/) содержит функцию `showScope()` которую можно использовать для
изучения изолированной области видимости и ассоциированной с ней включенной области. Смотрите инструкции в
комментариях к фидлу..

## Заключение

Существует четыре типа областей видимости:

  1. прототипически наследуемая область — ng-include, ng-switch, ng-controller, директивы с `scope: true`
  2. прототипически наследуемая область с несколькими копиями — ng-repeat. Каждая итерация ng-repeat создает новую
  дочернюю область видимости, и эта новая облать всегда получает новые свойства.
  3. изолированная область — директивы с `scope: {...}`. не наследуется прототипически, но «=», «@», и «&» 
  обеспечивают механизм для доступа к свойствам родительской области через атрибуты.
  4. включаемая область — директивы с `transclude: true`. Так же прототипически наследуется, но так же соседствует 
  с какой-то изолированной областью.

Для всех областей (наследуемых или нет), Angular всегда отслеживает отношения родитель-ребенок (т. е. иерархию),
через свойства $parent, $$childHead и $$childTail.

Диаграммы созданы с помощью [GraphViz](http://graphviz.org) «*.dot» файлов, которые лежат на 
[github](https://github.com/mrajcok/angularjs-prototypal-inheritance-diagrams).
Tim Caswell's ["Learning JavaScript with Object Graphs"](http://howtonode.org/object-graphs) был вовлечен в 
использование GraphViz для диаграмм.

первоначальное размещение оригинала [StackOverflow](http://stackoverflow.com/questions/14049480/what-are-the-nuances-of-scope-prototypal-prototypical-inheritance-in-angularjs).
