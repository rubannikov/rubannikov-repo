@workInProgress
@ngdoc overview
@name Developer Guide: E2E тестирование
@description

Со временем сложность и размеры приложения растут, и становится нереально рассчитывать на ручное тестирование 
для проверки корректности новых функций, отлова ошибок и объяснение регрессий.

Для решения этой проблемы, мы сделали в Angular исполнитель сценариев, который имитирует взаимодействие с 
пользователями, и поможет проверить работоспособность приложения.

# Обзор
Вы будете писать JavaScript-сценарии тестов, которые описывают, как должно вести себя приложение, учитывая 
определенные взаимодействия в определенном состоянии. Сценарий состоит из одного или более `it` блоков (можно 
думать о них как о требованиях вашего приложения), которые, в свою очередь состоят из **команд** и **ожиданий**. 
Команда говорит исполнителю сценария, что нужно сделать с приложением (например, перейти на страницу или 
нажать на кнопку), и ожидает, пока исполнитель не сообщит значение текущего состояния (например, значение 
поля или текущий URL-адрес). В случае несоответствия результата ожиданиям, исполнитель помечает блок `it` как «failed» 
и продолжает следующий. Сценарии могут также иметь блоки **beforeEach** и **afterEach**, которые будут выполняться до 
(или после) каждого блока `it`, независимо от того, пройден он или нет.

<img src="img/guide/scenario_runner.png">

В дополнение к вышеперечисленному сценарии могут содержать вспомогательные функции, которые призваны исключить 
дублирование кода в блоках `it`.

Пример простого сценария:
<pre>
describe('Buzz Client', function() {
it('should filter results', function() {
  input('user').enter('jacksparrow');
  element(':button').click();
  expect(repeater('ul li').count()).toEqual(10);
  input('filterText').enter('Bees');
  expect(repeater('ul li').count()).toEqual(1);
});
});
</pre>
Сценарий определяет блок требований Buzz Client, который проверяет работу фильтра для поля user. При старте 
вводится значение в поле ввода 'user' и щелкается кнопка на странице, а затем проверяется наличие 10 элементов 
всписке. Затем вводится 'Bees' в поле 'filterText' и проверяется, что остался один элемент.

В секции API приведен список доступных команд и ожиданий для исполнителя.

# API
Исходный код: {@link https://github.com/angular/angular.js/blob/master/src/ngScenario/dsl.js}

## pause()
Приостановка выполнения тестов до вызова функции `resume()` в консоли (или щелчке по ссылке resume в Runner UI).

## sleep(seconds)
Приостановка выполнения тестов через указанное количество секунд `seconds`.

## browser().navigateTo(url)
Загрузка содержимого `url` в тестовую область.

## browser().navigateTo(url, fn)
Загрузка URL, возвращенного функцией `fn` в тестовую область. Полученные `url` данные используются только для 
тестового вывода. Используется когда URL создается динамичестки (может быть он просто не определен во время написания 
теста).

## browser().reload()
Обновление текущей загруженной страницы в тестовой области.

## browser().window().href()
Возвращает window.location.href для текущей страницы, загруженной в тестовую область.

## browser().window().path()
Возвращает window.location.pathname для текущей страницы, загруженной в тестовую область.

## browser().window().search()
Возвращает window.location.search для текущей страницы, загруженной в тестовую область.

## browser().window().hash()
Возвращает window.location.hash (без `#`) для текущей страницы, загруженной в тестовую область.

## browser().location().url()
Возвращает {@link api/ng.$location $location.url()} для текущей страницы, загруженной в тестовую область.

## browser().location().path()
Возвращает {@link api/ng.$location $location.path()} для текущей страницы, загруженной в тестовую область.

## browser().location().search()
Возвращает {@link api/ng.$location $location.search()} для текущей страницы, загруженной в тестовую область.

## browser().location().hash()
Возвращает {@link api/ng.$location $location.hash()} для текущей страницы, загруженной в тестовую область.

## expect(future).{matcher}
Утверждение, что значение `future` должно удовлетворять условию `matcher`. Все методы API возвращают объект `future`, 
который получает значение `value` после того как закончится выполнение. Вычислители определяются с помощью 
`angular.scenario.matcher`, и используются для проверки будущих значений. Например: 
`expect(browser().location().href()).toEqual('http://www.google.com')`

## expect(future).not().{matcher}
Утверждение, что значение `future` не должно удовлетворять `matcher`.

## using(selector, label)
Выбор области для следующего DSL элемента.

## binding(name)
Возвращает значение первого связанного выражения с именем `name`.

## input(name).enter(value)
Вводит значение `value` в текстовое поле с именем `name`.

## input(name).check()
Ставит/убирает флажок в чекбокс с именем `name`.

## input(name).select(value)
Выбирает значение `value` в радио-кнопке с именем `name`.

## input(name).val()
Возвращается текущее значение элемента управления с именем `name`.

## repeater(selector, label).count()
Возвращает количество строк, которые соответствуют переданному селектору jQuery в параметре `selector`. 
`label` используется для тестового вывода.

## repeater(selector, label).row(index)
Возвращает из массива с привязками строку с индексом `index` в выражении повторителя с использованием селектора jQuery
`selector`. `label` используется для тестового вывода.

## repeater(selector, label).column(binding)
Возвращает из массива со значениями столбец `binding` для которого значение соответствует переданному jQuery селектору
`selector`. `label` используется для тестового вывода.

## select(name).option(value)
Проверка, что значение `value` выбрано в элементе select с именем `name`.

## select(name).option(value1, value2...)
Проверка, что все значения `values` выбраны в мультиселекте с именем `name`.

## element(selector, label).count()
Возвращает количество элементов, которые соответствуют jQuery селектору `selector`. `label` использутся 
для тестового вывода.

## element(selector, label).click()
Щелчки по элементу, найденному по jQuery селектору `selector`. `label` используется для тестового вывода.

## element(selector, label).query(fn)
Выполнение функции `fn(selectedElements, done)`, со значениями selectedElements которые находятся по jQuery селектору
`selector` и `done` — это функция, которая выполняется, когда завершается функция `fn`. `label` используется для 
тестового вывода.

## element(selector, label).{method}()
Возвращает результат выполнения метода `method` на элемента, найденом с помощью jQuery селектор `selector`, 
где `method` может быть любой из jQuery методов: `val`, `text`, `html`, `height`, `innerHeight`, `outerHeight`, 
`width`, `innerWidth`, `outerWidth`, `position`, `scrollLeft`, `scrollTop`, `offset`. `label` используется для 
тестового вывода.

## element(selector, label).{method}(value)
Выполняет `method`, передавая в качестве параметра `value` на элементе, найденом с помощью jQuery селектора `selector`, 
где `method` может быть любым из следующих методов jQuery: `val`, `text`, `html`, `height`, `innerHeight`, 
`outerHeight`, `width`, `innerWidth`, `outerWidth`, `position`, `scrollLeft`, `scrollTop`, `offset`. `label` 
используется для тестового вывода.

## element(selector, label).{method}(key)
Возвращает результат выполнения метода `method` которому в качестве параметра передаются ключ `key` на элементе, 
найденом с помощью jQuery селектора `selector`, где `method` может быть любым и следующих jQuery методов: `attr`, 
`prop`, `css`. `label` используется для тестового вывода.

## element(selector, label).{method}(key, value)
Выполняет метод `method` которому в качестве параметров передаются ключ `key` и значение `value` на элементе, 
найденом с помощью jQuery селектора `selector`, где `method` может быть любым и следующих jQuery методов: `attr`, 
`prop`, `css`. `label` используется для тестового вывода.

JavaScript — это динамически типизированный язык, который включает множество выражений, но от его компилятора 
практически нулевая помощь. По этой причине мы считаем очень хорошей практикой, что любой код, написанный на 
JavaScript необходимо пропустить через хороший набор тестов. Мы построили множество функций в Angular, которые 
делают тестирование Angular-приложений легким. Так что не может быть никаких оправданий, если вы не занимаетесь 
тестированием.
