@ngdoc overview
@name Developer Guide: Понимание директив
@description

### [Взято из AngularUI](https://github.com/angular-ui/angular-ui/blob/master/modules/directives/jq/README.md)

Этот документ (косвенно) пытается объяснить, как директивы AngularJS и связанный движок компиляции, работают так, 
чтобы вы не разбрасывали лапшу по кругу, когда в первый раз попытатаетесь взяться за дело самостоятельно.

## Внедряющая, компилирующая и связующая функции

Когда создается директива, по сути, определяется три функциональных слоя (на самом деле 
[включающая функция](http://docs.angularjs.org/guide/directive) является четвертым слоем, но она не используется uiJq).

<pre>
myApp.directive('uiJq', function InjectingFunction(){

  // === ВнедряющаяФункция === //
  // Выполняется только один раз в приложении или не выполняется (в зависимости от того, 
  //   используется ли директива).
  // Полезна для инициализации и глобальной настройки

  return {
    compile: function CompilingFunction($templateElement, $templateAttributes) {

      // === ФункцияКомпиляции === //
      // Выполняется один раз для каждого экземпляра ui-jq в исходном НЕОТРЕНДЕРЕНОМ
      //   шаблоне. 
      // Область видимости НЕДОСТУПНА, т. к. шаблоны только в кэше. МОЖНО исследовать 
      //   DOM и информацию из кэша о том, какие переменные и выражения будут
      //   использоваться, но пока нельзя определить их значения.
      // Angular закэшировал шаблоны и сейчас самое подходящее время, чтобы внедрить
      //   новые шаблоны в качестве потомков или будущих соседей для автоматического
      //  запуска.

      return function LinkingFunction($scope, $linkElement, $linkAttributes) {

        // === СвязующаяФункция === //
        // Выполняется один раз для каждого ОТРЕНДЕРЕНОГО экземпляра.
        // Один раз для каждой строки ng-repeat при её создании.
        // ng-if или ng-switch при выполнении также могут влиять.
        // Область видимости ДОСТУПНА, потому что логика контроллера уже отработала.
        // Все переменные и значения выражений могут быть окончательно определены.
        // Angular отрендерил кэш шаблонов. Уже поздно добавлять шаблоны для 
        //  автоматического запуска. Если НЕОБХОДИМО внедрить новые шаблоны, нужно 
        //  использовать $compile вручную
      };
    }
  };
})
</pre>

Доступ к данным можно получить _только_ в `$scope` внутри **СвязующейФункции**. Так как логика шаблона может удалять
или копировать элементы, то можно рассчитывать _только_ на окончательно настроенный DOM в **СвязующейФункции**. 
Всё еще _нельзя_ рассчитывать на потмков или соседей, так как они еще не связаны.

## Пре- и Пост-связующие функции
Везде, где можно использовать `LinkingFunction()`, вместо нее можно использовать объект с пре- и пост-связующими
функциями. [Как ни странно](https://github.com/angular/angular.js/issues/2592), `LinkingFunction()` является
`PostLinkingFunction()` по умолчанию:
<pre>
link: function LinkingFunction($scope, $element, $attributes) { ... }
...
link: {
  pre: function PreLinkingFunction($scope, $element, $attributes) { ... },
  post: function PostLinkingFunction($scope, $element, $attributes) { ... },
}
</pre>

Разница в том, что `PreLinkingFunction()` будет сначала обрабатывать родителя, а затем потомка и так далее.
`PostLinkingFunction()` идет в обратном направлении, обрабатывая сначала потомка, а затем родителя, и так далее.
Вот демо: {@link http://plnkr.co/edit/qrDMJBlnwdNlfBqEEXL2?p=preview}

**Когда нужно использовать обратное `PostLinking` поведение?** Иногда JQuery-плагину необходимо знать количество 
и размер потомков DOM элемента (например, слайд-шоу или менеджеру слоев, такому как Isotope). Есть несколько способов,
сделать поддержку этого:

* **(Наихудший)** Задержка выполнения плагина с использованием [$timeout](http://docs.angularjs.org/api/ng.$timeout)
* Вложенные директивы. Когда у каждого потомка есть директива, которая требует родительскую
  `require: '^parentDirective'` которая предоставит доступ к контроллеру `parentDirective`.
  * Если используется `PreLinkingFunction()` в `parentDirective`, можно создать пустой экземпляр контейнера,
  и затем обновлять его все время.

**Всё это _НЕ_ подходит для асинхронного изменения, такого как загрузка данных в `$scope` через AJAX**

Если необходимо подождать, пока в `$scope` не поступят данные, воспользуйтесь `ng-if` для отложенной загрузки 
блока DOM.

## $element === angular.element() === jQuery() === $()

Чтобы сделать работу с DOM проще, AngularJS содержит упрощенную версию JQuery, под названием jqlite. Она позволяет 
эмулировать некоторые из основных особенностей JQuery, используя _практически_ идентичный API. Каждый 
раз, когда видите DOM-элемент AngularJS, он будет эквивалентен элементу, обернутому в `JQuery()`.

**_НЕ_ следует оборачивать элементы AngularJS в `jQuery()`**

Если заметили, что полный набор методов JQuery (или плагинов) не доступен в элементе AngularJS, это потому, что
вы либо забыли загрузить библтотеку JQuery, либо забыли загрузить ее **ПЕРЕД** загрузкой AngularJS. Если AngularJS не 
увидит JQuery ко времени своей загрузки, то вместо неё будет использовать свою собственную библиотеку jqlite.

## $attributes.$observe()

Если имеется _соседский_ атрибут, который будет содержать `{{}}` то этот атрибут будет вычислен и даже может 
измениться несколько раз. **Не делайте это вручную!**

Вместо этого используйте `$attributes.$observe('myOtherAttribute', function(newValue))` так, как если бы вы
использовали `$scope.$watch()`. Единственным отличием является первый аргумент, в котором содержится имя атрибута
(не выражения) и колбэк, принимающий только новое значение `newValue` (уже вычисленное). Так же колбэк будет 
запускаться повторно всякий раз при изменении вычисленного выражения.

**Примечание:** Это означает, что к этому атрибуту можно получить доступ только _асинхронно_

**Примечание:** Если необходимо получить доступ к _достоверному_ предварительно вычисленному значению атрибута, 
то нужно сделать это в КомпилирующейФункции

## Расширение директив

Допустим, необходимо использовать стороннюю директиву, но вы хотите расширить ее не изменяя. Сделать это можно
несколькими способами.

### Глобальная настройка
Некоторые хорошо продуманные директивы (такие, как те, что содержатся в AngularUI) можно настроить глобально, 
так что не придется передавать им параметры настройки в каждом случае.
### Требование директив
Создайте новую директиву, которая предполагает, что первая директива уже применена. Можете потребовать ее присутствия
в родительском DOM-элементе, или на том же DOM-элементе. Если необходимо получить доступ к функциональности,
содержащейся в первичной директиве, получите доступ посредством контроллера директивы (может потребовать 
отправки запроса пулл реквеста или особого запроса к разработчику плагина).
<pre>
// <div a b></div>
ui.directive('a', function(){
  return {
    controller: function(){
      this.data = {}
      this.changeData = function( ... ) { ... }
    },
    link: ($scope, $element, $attributes, controller) {
      controller.data = { ... }
    }
  }
})
myApp.directive('b', function(){
  return {
    require: 'a',
    link: ($scope, $element, $attributes, aController) {
      aController.changeData()
      aController.data = { ... }
    }
  }
})
</pre>
### Наложение директив
Можно создать новую директиву с точно таким же именем, что и у оригинальной директивы. Обе директивы будет выполнены.
Тем не менее, можно использовать приоритетом для управления директивой, которая запускается первой (опять же, может
потребовать пулл реквеста или связи с разработчиками)
<pre>
// <div a></div>
ui.directive('a', ... )
myApp.directive('a', ... )
</pre>
### Шаблонизация
Можно использовать `<ng-include>` или просто создать директиву, которая генерирует HTML с основной директивой.
<pre>
// <div b></div>
ui.directive('a', ... )
myApp.directive('b', function(){
  return {
    template: '<div a="someOptions"></div>'
  }
})
</pre>
